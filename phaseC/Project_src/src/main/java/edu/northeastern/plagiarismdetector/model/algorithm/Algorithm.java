package edu.northeastern.plagiarismdetector.model.algorithm;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;

import java.util.HashMap;

import edu.northeastern.plagiarismdetector.util.antlr4.Python3Grammar.Python3Parser;

/**
 * This is the class for the hashing of the file lines.
 */
public class Algorithm implements IAlgorithm {


  // The hashed line values.
  private HashMap<Integer, Integer> hashWithLines;

  /**
   * This initializes an Algorithm object in order to use the methods.
   */
  public Algorithm() {
    hashWithLines = new HashMap<>();
  }


  @Override
  public void calculateHash(ParserRuleContext ctx, String language) {
    explore(ctx, language);
  }

  /**
   * A getter for the hashed line values.
   *
   * @return the hashed line values.
   */
  HashMap<Integer, Integer> getHashMap() {
    return hashWithLines;
  }

  /**
   * The hashing method based on the char ASCII values in the String.
   *
   * @param actual the String value of the atom nodes.
   * @return the hashed value of the String.
   */
  private int hashN(String actual) {
    int sum = 0;
    for (int i = 0; i < actual.length(); i++) {
      sum += actual.charAt(i);
    }
    return sum;
  }

  /**
   * This is the recursive method that iterates through an Antlr AST and grabs the atom nodes to be
   * hashed. We used atom nodes because they are the leaves of an Antlr AST.
   *
   * @param ctx the ParserRuleContext generated by Antlr.
   */
  private void explore(ParserRuleContext ctx, String language) {

    String actual = ctx.getText();
    int line = ctx.getStart().getLine();

    // The algorithm based on the language
    if (language.equals("Python")) {
      String ruleName = Python3Parser.ruleNames[ctx.getRuleIndex()];
      // Checks for atoms.
      if (ruleName.equals("atom")) {
        abstractCtxChecker(actual, line);
      }
    } else if (language.equals("C++")) {
      abstractCtxChecker(actual, line);
    }

    // The recursive call down the AST.
    for (int i = 0; i < ctx.getChildCount(); i++) {
      ParseTree element = ctx.getChild(i);
      if (element instanceof ParserRuleContext) {
        explore((ParserRuleContext) element, language);
      }
    }
  }


  /**
   * Hashes the value of the line and adds it to the HashMap
   *
   * @param actual the node being hashed.
   * @param line   the line number of the node.
   */
  private void abstractCtxChecker(String actual, int line) {

    int hashVal = hashN(actual);

    // Hashes the value of the whole line. Used because lines can contain multiple atoms and
    // we don't want to overwrite HashMap keys.
    if (hashWithLines.get(line) == null) {
      hashWithLines.put(line, hashVal);
    } else {
      int temp = hashWithLines.get(line);
      hashVal += temp;
      hashWithLines.put(line, hashVal);
    }
  }
}